# algorithm_everyday

## 算法思路_记录

### 线性表

#### 顺序表
- todo

#### 单链表

#### 需注意
- 删除节点时，记得使用 `free(node)` 释放节点空间
- 公共元素与公共节点不是同一概念，公共元素是指节点元素值相等，公共节点是指节点指针指向同一节点（即节点指针值相等）
- 对于有关2个元素值有序的线性表的问题，可以使用**归并**的思想

#### 查找2个单链表的公共节点
- 由于是单链表，所以每个node只有1个next指针，从第一个公共节点开始的所有节点都是公共节点
- 若只需判断是否有公共节点，只需分别遍历到2个单链表的最后一个节点并判断是否相同
- 若需求第一个公共节点，可以先分别求两个单链表的长度并求差值，对较长的单链表先遍历这个差值，再同步遍历同时判断next指针是否相等

#### 2个单链表元素值的匹配
- 不需要使用2个循环，只需记录两个链表的开始节点，每次匹配失败，通过开始节点恢复


### 栈与队列
#### 用栈实现队列
- 队列是先进先出，栈是先进后出，可以通过2个栈1个负责进1个负责出来实现
- 进的时候就直接进，出的时候一开始将进的栈的元素全都push到另一个栈中，从而实现元素顺序反向，之后出的时候，若出的栈有元素，则直接出，否则将进的栈的元素全都push到出的栈之后再出元素
#### 用队列实现栈
- 初步想法：使用2个队列，1个负责进栈和出栈，另一个辅助，关键在于维护进栈和出栈的队列中只有队尾的1个元素，其他元素按队列顺序保存在辅助队列中，当pop一个元素后，需将辅助队列的元素全部重新pop到主队列中，同时维护只有一个元素
- 优化：只使用1个队列，出栈时将出末尾元素都pop并重新push进入队列，值得注意的是top()只需返回队尾的元素back()，不应该使用pop出队列并重新入队列，否则多次top()会打乱顺序
#### 有效的括号
- 显然使用栈实现，但有2种思路，将左括号入栈并将右括号与之匹配，或者将左括号对应的右括号入栈并看是否相等
- 字符都遍历完后，还需要判断栈是否为空
#### 逆波兰表达式求值
- 逆波兰表达式即后缀表达式，显然使用栈求解
- 需要注意的是，出栈2个操作数的顺序，后出栈的是左操作数
#### 滑动窗口最大值
- 首先想到的是用队列维护当前窗口元素，但是如何维护最大值？
- 暴力求解，每次遍历k的值，时间复杂度O(nk)
- 由于每次只有一个元素的变化，似乎可以维护最大值和第二大值及其下标index。如果最大值移除且移入值小于第二大值，则第二大值更新为最大值，再遍历查找新的第二大值；如果最大值移除且移入值大于第二大值，则为最大值；如果最大值移除且移入值等于第二大值，则移入值为第二大值，原第二大值为最大值；如果有2个最大值，则应该index小的为最大值
- 使用最大堆维护最大值，移除元素时需要更新
- 使用双端队列维护最大值，双端队列元素的index递增，元素的值必须严格单调递减，因为，若相邻2个元素的下标为i和j，显然 i < j，只要i还在窗口中，j也一定还在窗口中，若nums[i] <= nums[j]，则nums[i]必然不会为窗口中的最大值，应该删去
#### 前k高频元素
- 首先，记录不同元素的频率，O(n), O(n)
- 其次，使用排序算法对频率及其元素进行排序；似乎使用堆排序的复杂度较低，O(n log k), O(n);
- 也可以使用快排，不过我已经忘记什么是快排了🤣

### 二叉树
#### 前中后序遍历
##### 递归法
- 要确定递归函数的参数和返回值；
  要确定递归终止的条件；
  要确定单层递归的逻辑。
- 有时可能需要写一个内部递归函数作为辅助
##### 迭代遍历
- 前序：
  - 将当前节点（中节点）的值加入结果集中，依次加入不为空的右节点、左节点到栈中
- 中序：
  - 空节点可以入栈
  - 将当前节点（中节点，不为空）入栈，cur赋值为左节点，若当前节点为空，则cur赋值为栈弹出的节点，将值加入结果集，再cur赋值为右节点
  - 相当于只处理中节点（值入结果集），左叶节点相当于左节点为空的中节点
- 后序：
  - 法1：
    - 前序的中左右顺序，调整为中右左顺序，再将结果集反向，变为左右中顺序，即后序
  - 法2：
    - 先直接遍历到最左叶节点的左节点（空节点）
    - 用pre指针记录刚才处理的节点
    - 若右节点为空或pre指针（刚才处理的节点）正好等于右节点，则处理当前节点（中节点）
##### 统一迭代法
- 栈中只存放非空节点
- 相当于统一只处理中节点，当前节点（中节点）放入栈中后紧接着要放入nullptr空节点作为标记，标志当前节点已访问，下次出栈时就直接处理，左右非空节点按照前中后序的顺序相应的入栈
#### 层序遍历
- 使用队列辅助存储
- 处理每一层之前，使用int size记录当前层的节点数目
#### 翻转二叉树
- 递归法、统一迭代法（前中后序）、广度优先搜索（层序遍历）都可以
#### 对称二叉树
- 可以使用递归法或迭代法
- 关键在于每次处理2个对称位置的节点，按对称顺序处理子节点（左左与右右、左右与右左）
#### 二叉树的最大深度
- 首先，想到的是递归法(深度优先搜索)
- 还可以使用层序遍历，深度显然与层数直接相关
#### 二叉树的最小深度
- 需要注意的是，最小深度是根节点到最近的叶子节点的路径的节点数，若左子树为空，则最小深度=1+右子树的最小深度
- 可以使用DFS（递归法）
- 也可以使用BFS（层序遍历），当第一次遇到叶子节点，就返回
#### 完全二叉树的节点数
- 若只当作普通二叉树，可以使用递归法：1+左子树节点数+右子树节点数，也可以使用迭代法，如层序遍历
- 若利用完全二叉树的性质，通过一直向左子树遍历、向右子树遍历来判断是不是满二叉树，如果是，则按照公式计算，如果不是，则使用递归：1+f(left)+f(right)
#### 平衡二叉树
- 总体思路是自顶向下或自底向上
- 自顶向下若不记录已经计算过的值，则复杂度较高
- 自底向上可以使用后序遍历递归法
#### 二叉树的所有路径
- 根节点到所有节点的路径：首先想到的是DFS，由于要记录经过路径的节点，所以使用前序遍历
- 可以使用递归法或迭代法。关键在于回溯，处理一个叶节点后需要回溯到父节点的路径。迭代法需要使用辅助栈记录每个节点的路径。
#### 左叶子之和
- 左叶子节点的判断需要从父节点开始判断，也可以通过引入应该bool参数判断该节点是否为左叶子节点
- dfs可以使用迭代法实现
- bfs可以使用迭代法实现
#### 找树左下角的值
- 对于找最下一层最左边的值，首先想到的是层序遍历，可以每次记录一层中最左边的值，遍历结束后最后一个即为所求
- 也可以使用递归法，参数需要包含节点指针、当前深度，同时还要设置全局性的变量存储已知最大深度和最大深度最左边的节点值，需要保证优先搜索左边节点，前、中、后序都行
#### 路径总和
- 寻找是否存在一条由根节点到叶子节点的路径，使得节点值之和等于目标值
- 可以借助[二叉树的所有路径](#二叉树的所有路径)部分，依次遍历所有路径并且节点值之和
#### 从中序与后序遍历序列构造二叉树
- 中序遍历的顺序为：左中右，后序遍历的顺序为左右中，可以想象出，后序遍历的最后一个节点一定是根节点，由于没有重复元素，因此可以在中序遍历的数组中找到根节点，从而确定左子树和右子树的数组部分和大小，从而可以进行递归处理
#### 最大二叉树
- 此最大二叉树是递归定义的：找到数组中最大值作为根节点，然后左右子树分别使用根节点左右两边的数组递归构造
- 那么，如何寻找最大值很重要，由于原数组未排序，所以不能使用二分法，那么似乎只能一个一个比较
#### 合并二叉树
- 关键点在于如何同时同步遍历两个树
- 使用递归法较为简便，前中后序都可以
#### 二叉搜索树中的搜索
- 需要注意二叉搜索树BST的性质，左子树的值<根节点的值<右子树的值，递归定义
- 可以直接使用递归法
- 由于BST的性质导致节点值的顺序性，我们在确定搜索方向后就不需要再改变了（因为左子树的值<根节点的值<右子树的值），即不需要再回溯了，因此也可以使用迭代法通过while循环知道找到节点或nullptr
#### 验证二叉搜索树
- 显然，根据BST的递归定义，可通过暴力搜索左子树最大值和右子树最小值进行判断并递归调用
- 进一步优化，暴力求最大最小的方法会重复遍历节点，递归时每次都求最大和最小，效率低，可以将递归函数设置为判断子树的值是不是在指定范围内，同时每次递归只比较一次根节点的值
- 根据BST的性质，则中序遍历的值一定是严格升序的，只需判断当前值是否大于之前的节点值
#### 二叉搜索树的最小绝对差
- 注意树是二叉搜索树，所以可以求 当前节点值-左子树最大值 和 右子树最小值-当前节点值 进行比较，并递归调用
- 还是可以利用中序遍历，先求出递增序列，然后遍历求最小绝对差就行
#### 二叉搜索树中的众数
- 可以先中序遍历转换为升序数组 O(n)，再遍历 O(n)
- 优化：无需转换为升序数组，直接在中序遍历时计数，再将map转换为vector，进行排序
- 优化：根据二叉搜索树的性质，中序遍历为非递减序列，我们只需在遍历时记录上一次的值，相等时计数+1，不等时结束上一个计数并与最大计数比较，开始当前计数
#### 二叉树的最近公共祖先
- 如果2个节点分别在当前节点的左右子树中，那么最近公共祖先就是当前节点；如果都在一个子树中，则可以递归判断该子树
- 如果先判断是否在子树中，再递归地在子树中搜索，复杂度太高
- 可以通过递归返回指针指示是否在子树中，同时通过后序遍历实现所谓的回溯（自底向上查找）
- 还可以先遍历一遍记录所有节点的父节点，从而实现像我们自己查找最近公共祖先那样自底向上查找
#### 二叉搜索树的最近公共祖先
- 根据二叉搜索树的性质，只需当前节点值在p和q值之间就可以确定是最近公共祖先
#### 二叉树的插入操作
- 递归比较大小进行插入
- 或者使用迭代法进行模拟
#### 删除二叉搜索树中的节点
- 递归地找到要删除的节点，再将以此节点为根节点的树删除根节点后重构为二叉搜索树
#### 修剪二叉搜索树
- 递归法，遇到空节点直接返回nullptr；若当前节点值不在控制区间内，则返回对可能符合范围的左子树或右子树的递归调用；若当前节点值在控制区间内，则继续对左右儿子递归调用
- 由于二叉搜索树的有效性，可以直接使用迭代法进行处理
#### 将有序数组转换为二叉搜索树
- 数组为升序，二叉搜索树要求为平衡
- 可以使用递归，每次选中间节点作为根节点，再对左右子树和左右子数组递归调用
#### 把二叉搜索树转换为累加树
- 累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
- 根据二叉搜索树的性质，可以按照由大到小的顺序即右、中、左的顺便遍历

![二叉树汇总表](https://code-thinking-1253855093.file.myqcloud.com/pics/20211030125421.png)

### 回溯算法
#### 模板
```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
#### 组合总和
- 由于每个数可以重复使用，所以每次递归元素范围不会缩减，而是通过元素之和大于给定值来终止
#### 组合总和2
- 元素可以有重复，但每个元素只能用1次，同时结果中不能有重复
- 需要进行去重，可以考虑使用set或map等结构，但可能需要进行类型转换，可能超时
- 可以先对数组进行排序，然后使用bool数组进行标记，通过比较当前元素是否等于前一个元素同时前一个相等元素是否在当前路径中用过，来排除重复
#### 分割回文串
#### 复原IP地址
- 输入字符串只包含数字，要求输出所有可能的有效IP地址
- 可以先根据输入字符串的长度确定对应4个整数的分割，再进行有效性判断
#### 子集2
- 考虑包含重复元素值的集合，求幂集，
- 所求子集要去重，将过程用树表示，树层去重、树枝去重
#### 非递减子序列
- 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。
- 与子集2不同，不能对数据进行排序，去重逻辑不同
- 要将树上的所有超过1个元素的节点加到结果中
- 去重逻辑：同一父节点的同层节点是否已经使用过该元素
#### 全排列
- 需要使用一个数组used用于记录已使用的元素
#### 全排列2
- 有重复元素，所以需要去重，思路还是同一层和同一path上的重复元素的区别
#### N皇后
- 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
#### 解数独
- 数独定义：每一行不能有相同数字，每一列不能有相同数字，每个3x3的块不能有相同数字
- 易错点：3x3判断中索引范围
- 可以优化的点：backtracking通过返回bool值结束递归，没有使用单独的索引和判断递归中止的语句，之后可以加上进行性能比较

### 贪心算法
#### 最大子数组和
- 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
- 子数组是数组中的一个连续部分。
- 此题使用贪心算法的关键在于如果当前连续子序列的和为负数，就不应该再使用当前子序列了，而是重新开始，因为负数和已经拉低了总和；
  同时，不用担心重新开始子序列会导致漏掉可能的子序列，因为假如之前负数和的子序列存在非负的子子序列，要么已经记录了子子序列的最大和，要么是前半部为负数和（序列已经重新开始了，所以不存在这种情况）。

#### 买卖股票的最佳时机2
- 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
  在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
  返回 你能获得的 最大 利润 。
- 基于贪心算法，谷底买峰顶卖

#### 跳跃游戏
- 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
  判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。
- 可以模拟人工判断时的暴力求解，从起始位置开始计算可以到达的最远位置，直到终止（其实就是贪心的算法）
- 一个重要的性质：只要有1条到达某个index的路径，那么该index之前的任何位置都可以到达，所以只需要关心可以到达的最远位置就行

#### 跳跃游戏2
- 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。
- 根据直觉，从0位置开始每次选择跳到最远的距离，但是似乎有反例
- 由于肯定能到达n-1的位置，在之前的求是否可以到达n-1的算法中每次更新max_index时计数+1，但是似乎不行
- 根据随想录，贪心贪在步数什么时候+1，若终点在当前位置所辐射的范围内，则终止，否则步数+1

#### k次取反后最大化的数组和
- 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。重复这个过程恰好 k 次。可以多次选择同一个下标 i 。以这种方式修改数组后，返回数组 可能的最大和 。
- 设数组中负数的个数为 num_neg，若 k<=num_neg，则取反最小的k个负数；若k>num_neg，则看数组中是否有0，若有0则先将所有负数取反，再将k剩余的次数用到0上，若没有0，则看k-num_neg的奇偶性，若k-num_neg为奇数，则选择最小的正数将其反转为负数，若k-num_neg为偶数，则不反转
- 随想录的思路也类似，不过我最开始没想到可以相对数组进行排序（题目没要求不能改变数组），排序后就很容易找到最小的k个负数

#### 加油站
- 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回-1 。如果存在解，则 保证 它是 唯一 的。
- 对于像 `gas = [1,2,3,4,5], cost = [3,4,5,1,2]` 之类的输入，首先需要遍历找到一个开始的 gas[i]>=cost[i]，之后每次计算gas之和与cost之和，始终保证gas之和>=cost之和就能保证能够正常行驶，但是时间复杂度为O(n^2)
- O(n)的算法：如果在i处发生剩余的油量rest[i]<0，则说明i及之前的位置都不能作为起始点（反证法），将i+1作为新的起始点，同时记录总的剩余量，如果遍历一圈后总剩余量<0，则必然无法走一周。

#### 分发糖果
- n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：每个孩子至少分配到 1 个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。
- 随想录的思路：若孩子i右边的孩子i+1评分比i大，则糖果数candy[i+1]必定>candy[i]，由于要求最少糖果数目，所以相邻取candy[i+1]=candy[i]；同时从左到右与从右到左都分别有连续的评分关系，所以需要分别从右到左和从左到右遍历，初始化时将每个孩子的糖果数都初始化为1；同时，第二次遍历时，糖果数目不仅要取candy[i+1]+1和candy[i]的最大值，以保证即大于右边又大于左边

#### 柠檬水找零
- 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
- 10元需要有至少1张5元，20元需要1张10元1张5元 或 3张5元

#### 用最少数量的箭引爆气球
- 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

#### 无重叠区域
- 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。
- 首先，需要给出重叠的定义：对于[start_i, end_i]和[start_j, end_j], 若start_j < end_i && end_j > start_i 或者是i和j对调，则两个intervals重叠。若按照此定义，判断重叠时则需要进行i和j对调的两种比较，因此可以想到在比较判断之前先通过interval的左边界或右边界进行排序，那么在对2个intervals进行比较时就可以少去1个判断。
- 假设对左边界进行排序，就会存在左边界相等右边界不等的情况，根据贪心的思想，此时要尽可能使得右边界变小，从而到最终的右边界的剩余空间就越大，由于intervals已经进行了排序，所以剩余空间越大，可容纳的不重叠区域的个数就越多

#### 划分字母区间
- 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。返回一个表示每个字符串片段的长度的列表。
- 如果一个字母出现在index为i和j的位置，那么[i, j]必定包含在一个片段中，那么可以先记录26个字母最开始和结束的位置，然后进行片段的划分——可分为3种情况，该字母没有出现、只出现1次和出现2次及以上，由此得到的若干个区间，重叠的区间合并为一个大区间，类似于求无重叠区域的问题，但是右边界要求较大值
- 进一步优化，只需记录每个字母最后出现的位置，对于每一个片段，若index达到当前片段的最右边界，则说明片段结束